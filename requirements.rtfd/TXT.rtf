{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc3\levelnfcn3\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{upper-alpha\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-latin\}.}{\leveltext\leveltemplateid102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\tx720\pardeftab720\sa320

\f0\b\fs48 \cf0 Instructions:
\b0\fs32 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls1\ilvl0\cf0 {\listtext	A.	}\expnd0\expndtw0\kerning0
Your program must read 8-bit ASCII strings from standard input -- for instance, using the cin object in C++, or stdin in C. You must consume all input from standard input. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	B.	}\expnd0\expndtw0\kerning0
Your must tokenize the entire input stream, using the lexical specification below to dictate how to break the stream into tokens. \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	C.	}\expnd0\expndtw0\kerning0
You must then output tokens to standard output (e.g., via cout in C++ or stdout in C), using the token information chart below to dictate what information you print about each token. Note that the lexical pattern, when italicized, refers to the pattern from the lexical specification above. 
\fs24 \expnd0\expndtw0\kerning0
\
\pard\tx720\pardeftab720\sa240
\cf0 \
\

\b\fs48 Output Requirements:
\b0\fs32 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
If the input contains unterminated strings, then instead of generating a string token, generate a single ERR2 token. The position indicator for the token should correspond to the beginning quote starting the string. Consume all input up to (but not including) the first newline. If there is no next newline, consume all remaining input. The length associated with the token should be reported appropriately. \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
The alphabet for this assignment consists of the following: \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sa320
\ls2\ilvl1\cf0 \kerning1\expnd0\expndtw0 {\listtext	a.	}\expnd0\expndtw0\kerning0
ASCII 0x09 and 0x0a (tab and newline) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	b.	}\expnd0\expndtw0\kerning0
ASCII 0x20 through 0x7e (all printable ASCII characters). \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
If you are in the middle of processing a string (meaning, you have seen the opening quote but not the end quote), and you then see a character that is not part of the alphabet, treat the bad character as if it were a newline for the sake of processing the string. That is, generate an ERR2 token for an unterminated string, and have the token end right before the bad character (meaning tokenization should resume at the bad character). \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
When you see one or more consecutive characters that are not in the alphabet, group them together and generate an ERR3 token. The length associated with the token should be the number of consecutive characters that are not in our alphabet. Resume tokenizing as normal after the bad characters. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	5.	}\expnd0\expndtw0\kerning0
If you see a character in the alphabet that is not valid in its context, generate an ERR4 token for just the one character. If there are multiple such characters consecutively, generate multiple tokens. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	6.	}\expnd0\expndtw0\kerning0
When outputting a token, your output must consist of the following, in order: \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sa320
\ls2\ilvl1\cf0 \kerning1\expnd0\expndtw0 {\listtext	a.	}\expnd0\expndtw0\kerning0
\'93TID:\'94, with no spaces (or other characters) proceeding. All letters \uc0\u8232 shall be output as capital ASCII letters. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	b.	}\expnd0\expndtw0\kerning0
The colon may optionally be followed by spaces. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	c.	}\expnd0\expndtw0\kerning0
The Token ID of the token you are outputting. Token IDs must start at \uc0\u8232 1 and increase by 1 for each token of the input. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	d.	}\expnd0\expndtw0\kerning0
A single comma (note the token ID shall NOT be followed by spaces) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	e.	}\expnd0\expndtw0\kerning0
The comma may optionally be followed by spaces \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	f.	}\expnd0\expndtw0\kerning0
\'93TYPE:\'94. All letters shall be output as capital ASCII letters. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	g.	}\expnd0\expndtw0\kerning0
The colon may optionally be followed by spaces. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	h.	}\expnd0\expndtw0\kerning0
An integer representing the 
\i \expnd0\expndtw0\kerning0
Numeric Type 
\i0 \expnd0\expndtw0\kerning0
of the token. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	i.	}\expnd0\expndtw0\kerning0
The integer must only be followed by a left parenthesis\'97 \'93(\'93, meaning \uc0\u8232 no spaces before the \'93(\'93. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	j.	}\expnd0\expndtw0\kerning0
The left parenthesis must be followed by the \'93English Type\'94 of the \uc0\u8232 token (as indicated in the table above \'96 case sensitive!), with no \u8232 spaces preceding. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	k.	}\expnd0\expndtw0\kerning0
The English Type must be followed by a right parenthesis and \uc0\u8232 comma\'97 \'93),\'94, meaning no spaces before the \'93),\'94 \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	l.	}\expnd0\expndtw0\kerning0
The comma may optionally be followed by spaces. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	m.	}\expnd0\expndtw0\kerning0
\'93POS:\'94. All letters shall be output as capital ASCII letters. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	n.	}\expnd0\expndtw0\kerning0
The colon may be optionally followed by spaces. \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls2\ilvl1\cf0 \kerning1\expnd0\expndtw0 {\listtext	o.	}\expnd0\expndtw0\kerning0
An integer representing the position of the first character in the original input that led to the token match. The position is numbered from 0, and represents the number of 8-bit ASCII characters in the input stream that precede the character in question. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	p.	}\expnd0\expndtw0\kerning0
The integer must be followed by a single comma, with NO spaces (or other characters) in between. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	q.	}\expnd0\expndtw0\kerning0
The comma may optionally be followed by spaces. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	r.	}\expnd0\expndtw0\kerning0
\'93LEN:\'94. All letters shall be output as capital ASCII letters. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	s.	}\expnd0\expndtw0\kerning0
An integer representing the number of bytes matched in the current \uc0\u8232 token. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	t.	}\expnd0\expndtw0\kerning0
If the chart above indicates \'93None\'94 in the \'93Value to output\'94 column, \uc0\u8232 then print a single newline (ASCII 0x0a \'96 \'91\\n\'92). The newline may optionally be preceded by spaces. IF THERE IS NO VALUE TO OUTPUT, YOU ARE DONE PRINTING THIS TOKEN. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	u.	}\expnd0\expndtw0\kerning0
The rest of the bullets are for when you are outputting a value only. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	v.	}\expnd0\expndtw0\kerning0
Output a comma (with NO preceding spaces), optionally followed by \uc0\u8232 spaces, followed by \'93VALUE:\'94, optionally followed by spaces. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	w.	}\expnd0\expndtw0\kerning0
Output the value, per the \'93Value to output\'94 column above. All items \uc0\u8232 that have a value should be a simple copy of the input, except for \u8232 strings, which should omit the quotation marks around the string. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	x.	}\expnd0\expndtw0\kerning0
Print a single newline (ASCII 0x0a \'96 \'91\\n\'92). The newline may optionally \uc0\u8232 be preceded by spaces. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	y.	}\expnd0\expndtw0\kerning0
Your program must take an optional command-line argument that dictates \uc0\u8232 which tokens get output.\u8232 a. If no command line argument is given, then you must output all \u8232 tokens in the token stream.\u8232 b. If the command line argument is a 0, you must also output all tokens \u8232 in the token stream.\u8232 c. If the command line argument is a 1, you must output all tokens \u8232 EXCEPT comments, whitespace, errors and newlines.\u8232 d. If the command line argument is a 2, you must output ONLY tokens for \u8232 comments, whitespace, errors and newlines.\u8232 e. If the command line consists of anything else other than the above \u8232 four options, then you should IGNORE all input from stdin, assume the input length is 0, and populate the token stream with only a single token of type ERR1, which you will then output, per below. \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	z.	}\expnd0\expndtw0\kerning0
After reading in the entire input and generating tokens, output all tokens per the above specification. When you are done outputting all tokens you are supposed to output, then output the following: \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sa320
\ls2\ilvl1\cf0 \kerning1\expnd0\expndtw0 {\listtext	a.	}\expnd0\expndtw0\kerning0
An additional newline (creating a blank line) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	b.	}\expnd0\expndtw0\kerning0
The string \'93Totals:\'94 (case sensitive, as with all strings in this \uc0\u8232 assignment) \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	c.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	d.	}\expnd0\expndtw0\kerning0
The string \'93len\'94 \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	e.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	f.	}\expnd0\expndtw0\kerning0
An equals sign \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls2\ilvl1\cf0 \kerning1\expnd0\expndtw0 {\listtext	g.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	h.	}\expnd0\expndtw0\kerning0
An integer indicating the length of the input stream (always 0 with \uc0\u8232 ERR1, remember!) \u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	i.	}\expnd0\expndtw0\kerning0
A comma \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	j.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	k.	}\expnd0\expndtw0\kerning0
The string \'93tokens\'94 \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	l.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	m.	}\expnd0\expndtw0\kerning0
An equals sign \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	n.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	o.	}\expnd0\expndtw0\kerning0
An integer indicating the number of tokens in the token stream. \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	p.	}\expnd0\expndtw0\kerning0
A comma \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	q.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	r.	}\expnd0\expndtw0\kerning0
The string \'93printed\'94 \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	s.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	t.	}\expnd0\expndtw0\kerning0
An equals sign \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	u.	}\expnd0\expndtw0\kerning0
Optional space(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	v.	}\expnd0\expndtw0\kerning0
An integer indicating the number of tokens you OUTPUT \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	w.	}\expnd0\expndtw0\kerning0
Optionalspace(s) \uc0\u8232 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	x.	}\expnd0\expndtw0\kerning0
A single newline. \uc0\u8232 \
\pard\pardeftab720\sa240
\ls2\ilvl1\cf0 \kerning1\expnd0\expndtw0 \
\ls2\ilvl1\expnd0\expndtw0\kerning0
9.  After you finish outputting, your program must exit. \uc0\u8232 \
}